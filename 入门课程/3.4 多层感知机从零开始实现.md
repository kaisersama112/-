为了与之前softmax回归获得的结果进行比较， 我们将继续使用Fashion-MNIST图像分类数据集。

## 初始化模型参数

回想一下，Fashion-MNIST中的每个图像由 28*28=784个灰度像素值组成。 所有图像共分为10个类别。 忽略像素之间的空间结构， 我们可以将每个图像视为具有784个输入特征 和10个类的简单分类数据集。 首先，我们将实现一个具有单隐藏层的多层感知机， 它包含256个隐藏单元。 注意，我们可以将这两个变量都视为超参数。 通常，我们选择2的若干次幂作为层的宽度。 因为内存在硬件中的分配和寻址方式，这么做往往可以在计算上更高效。
我们用几个张量来表示我们的参数。 注意，对于每一层我们都要记录一个权重矩阵和一个偏置向量。 跟以前一样，我们要为损失关于这些参数的梯度分配内存。



```python
import torch
from torch import nn
from d2l import torch as d2l

batch_size = 256
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)

num_inputs, num_outputs, num_hiddens = 784, 10, 256

w1 = nn.Parameter(torch.randn(
    num_inputs, num_hiddens, requires_grad=True) * 0.01)
b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True))
w2 = nn.Parameter(torch.randn(
    num_hiddens, num_outputs, requires_grad=True) * 0.01)
b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True))

params = [w1, b1, w2, b2]


# 激活函数
def relu(x):
    a = torch.zeros_like(x)
    return torch.max(x, a)


# 模型
"""
因为我们忽略了空间结构， 所以我们使用reshape将每个二维图像转换为一个长度为num_inputs的向量。 只需几行代码就可以实现我们的模型。
"""


def net(x):
    x = x.reshape((-1, num_inputs))
    h = relu(torch.dot(x, w1) + b1)
    return (torch.dot(h, w2) + b2)


# 损失函数
"""
之前我们已经从零实现过softmax函数， 因此在这里我们直接使用高级API中的内置函数来计算softmax和交叉熵损失。 回想一下我们之前对这些复杂问题的讨论。
"""
loss = nn.CrossEntropyLoss(reduction="none")

# 训练

num_epochs, lr = 10, 0.1
updeter = torch.optim.SGD(params, lr=lr)
d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, updeter)

# 为了对学习到的模型进行评估，我们将在一些测试数据上应用这个模型。
d2l.predict_ch3(net, test_iter)

```


    ---------------------------------------------------------------------------

    ImportError                               Traceback (most recent call last)

    Cell In[2], line 3
          1 import torch
          2 from torch import nn
    ----> 3 from d2l import torch as d2l
          5 batch_size = 256
          6 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)
    

    File F:\minconda\envs\d2l\lib\site-packages\d2l\torch.py:35
         33 import requests
         34 from IPython import display
    ---> 35 from matplotlib import pyplot as plt
         36 from matplotlib_inline import backend_inline
         38 d2l = sys.modules[__name__]
    

    File F:\minconda\envs\d2l\lib\site-packages\matplotlib\__init__.py:208
        203         if parse_version(module.__version__) < parse_version(minver):
        204             raise ImportError(f"Matplotlib requires {modname}>={minver}; "
        205                               f"you have {module.__version__}")
    --> 208 _check_versions()
        211 # The decorator ensures this always returns the same handler (and it is only
        212 # attached once).
        213 @functools.lru_cache()
        214 def _ensure_handler():
    

    File F:\minconda\envs\d2l\lib\site-packages\matplotlib\__init__.py:204, in _check_versions()
        202 module = importlib.import_module(modname)
        203 if parse_version(module.__version__) < parse_version(minver):
    --> 204     raise ImportError(f"Matplotlib requires {modname}>={minver}; "
        205                       f"you have {module.__version__}")
    

    ImportError: Matplotlib requires numpy>=1.17; you have 1.16.6





```python

```


```python

```


```python

```


```python

```
