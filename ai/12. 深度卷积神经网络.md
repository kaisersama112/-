# 现代卷积神经网络

​		在LeNet提出后，卷积神经网络在计算机视觉和机器学习领域中很有名气。但卷积神经网络并没有主导这些 领域。这是因为虽然LeNet在小数据集上取得了很好的效果，但是在更大、更真实的数据集上训练卷积神经 网络的性能和可行性还有待研究。事实上，在上世纪90年代初到2012年之间的大部分时间里，神经网络往往 被其他机器学习方法超越，如支持向量机（support vector machines）。

​		在计算机视觉中，直接将神经网络与其他机器学习方法进行比较也许不公平。这是因为，卷积神经网络的输 入是由原始像素值或是经过简单预处理（例如居中、缩放）的像素值组成的。但在使用传统机器学习方法时， 从业者永远不会将原始像素作为输入。在传统机器学习方法中，计算机视觉流水线是由经过人的手工精心设 计的特征流水线组成的。对于这些传统方法，大部分的进展都来自于对特征有了更聪明的想法，并且学习到 的算法往往归于事后的解释。

​		虽然上世纪90年代就有了一些神经网络加速卡，但仅靠它们还不足以开发出有大量参数的深层多通道多层卷 积神经网络。此外，当时的数据集仍然相对较小。除了这些障碍，训练神经网络的一些关键技巧仍然缺失，包 括启发式参数初始化、随机梯度下降的变体、非挤压激活函数和有效的正则化技术。 因此，与训练端到端（从像素到分类结果）系统不同，经典机器学习的流水线看起来更像下面这样： 

  		1. 获取一个有趣的数据集。在早期，收集这些数据集需要昂贵的传感器（在当时最先进的图像也就100万 像素）。 
  		2. 根据光学、几何学、其他知识以及偶然的发现，手工对特征数据集进行预处理。 
  		3. 通过标准的特征提取算法，如SIFT（尺度不变特征变换）(Lowe, 2004)和SURF（加速鲁棒特征）(Bay et al., 2006)或其他手动调整的流水线来输入数据。 
  		4. 将提取的特征送入最喜欢的分类器中（例如线性模型或其它核方法），以训练分类器。

​		当人们和机器学习研究人员交谈时，会发现机器学习研究人员相信机器学习既重要又美丽：优雅的理论去证 明各种模型的性质。机器学习是一个正在蓬勃发展、严谨且非常有用的领域。然而，当人们和计算机视觉研 究人员交谈，会听到一个完全不同的故事。计算机视觉研究人员会告诉一个诡异事实————推动领域进步的 是数据特征，而不是学习算法。计算机视觉研究人员相信，从对最终模型精度的影响来说，更大或更干净的 数据集、或是稍微改进的特征提取，比任何学习算法带来的进步要大得多。

## 1. 深度卷积神经网络（AlexNet）

### 1.1 学习表征

​		另一种预测这个领域发展的方法————观察图像特征的提取方法。在2012年前，图像特征都是机械地计算出 来的。事实上，设计一套新的特征函数、改进结果，并撰写论文是盛极一时的潮流。SIFT (Lowe, 2004)、SURF (Bay et al., 2006)、HOG（定向梯度直方图）(Dalal and Triggs, 2005)、bags of visual words88和类似的特征提 取方法占据了主导地位。

​		另一组研究人员，包括Yann LeCun、Geoff Hinton、Yoshua Bengio、Andrew Ng、Shun ichi Amari和Juergen Schmidhuber，想法则与众不同：他们认为特征本身应该被学习。此外，他们还认为，在合理地复杂性前提下， 特征应该由多个共同学习的神经网络层组成，每个层都有可学习的参数。在机器视觉中，最底层可能检测边缘、颜色和纹理。事实上，Alex Krizhevsky、Ilya Sutskever和Geoff Hinton提出了一种新的卷积神经网络变 体AlexNet。在2012年ImageNet挑战赛中取得了轰动一时的成绩。AlexNet以Alex Krizhevsky的名字命名，他 是论文 (Krizhevsky et al., 2012)的第一作者。

![image-20240531101448623](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531101448623.png)

​		有趣的是，在网络的最底层，模型学习到了一些类似于传统滤波器的特征抽取器。

​		AlexNet的更高层建立在这些底层表示的基础上，以表示更大的特征，如眼睛、鼻子、草叶等等。而更高的层 可以检测整个物体，如人、飞机、狗或飞盘。最终的隐藏神经元可以学习图像的综合表示，从而使属于不同 类别的数据易于区分。尽管一直有一群执着的研究者不断钻研，试图学习视觉数据的逐级表征，然而很长一 段时间里这些尝试都未有突破。深度卷积神经网络的突破出现在2012年。突破可归因于两个关键因素。

#### 1.1.1 缺少的成分：数据

​		包含许多特征的深度模型需要大量的有标签数据，才能显著优于基于凸优化的传统方法（如线性方法和核方 法）。然而，限于早期计算机有限的存储和90年代有限的研究预算，大部分研究只基于小的公开数据集。例 如，不少研究论文基于加州大学欧文分校（UCI）提供的若干个公开数据集，其中许多数据集只有几百至几 千张在非自然环境下以低分辨率拍摄的图像。这一状况在2010年前后兴起的大数据浪潮中得到改善。2009年， ImageNet数据集发布，并发起ImageNet挑战赛：要求研究人员从100万个样本中训练模型，以区分1000个不同 类别的对象。ImageNet数据集由斯坦福教授李飞飞小组的研究人员开发，利用谷歌图像搜索（Google Image Search）对每一类图像进行预筛选，并利用亚马逊众包（Amazon Mechanical Turk）来标注每张图片的相关 类别。这种规模是前所未有的。这项被称为ImageNet的挑战赛推动了计算机视觉和机器学习研究的发展，挑 战研究人员确定哪些模型能够在更大的数据规模下表现最好。

#### 1.1.2缺少的成分：硬件

​		深度学习对计算资源要求很高，训练可能需要数百个迭代轮数，每次迭代都需要通过代价高昂的许多线性代 数层传递数据。这也是为什么在20世纪90年代至21世纪初，优化凸目标的简单算法是研究人员的首选。然而， 用GPU训练神经网络改变了这一格局。图形处理器（Graphics Processing Unit，GPU）早年用来加速图形处 理，使电脑游戏玩家受益。GPU可优化高吞吐量的4 × 4矩阵和向量乘法，从而服务于基本的图形任务。幸运 的是，这些数学运算与卷积层的计算惊人地相似。由此，英伟达（NVIDIA）和ATI已经开始为通用计算操作 优化gpu，甚至把它们作为通用GPU（general‐purpose GPUs，GPGPU）来销售。

​		首先，我们深度理解一下中央处理器（Central Processing Unit，CPU）的核心。CPU的每个核心都拥有高时 钟频率的运行能力，和高达数MB的三级缓存（L3Cache）。它们非常适合执行各种指令，具有分支预测器、深 层流水线和其他使CPU能够运行各种程序的功能。然而，这种明显的优势也是它的致命弱点：通用核心的制 造成本非常高。它们需要大量的芯片面积、复杂的支持结构（内存接口、内核之间的缓存逻辑、高速互连等 等），而且它们在任何单个任务上的性能都相对较差。现代笔记本电脑最多有4核，即使是高端服务器也很少 超过64核，因为它们的性价比不高。

​		相比于CPU，GPU由100 ∼ 1000个小的处理单元组成（NVIDIA、ATI、ARM和其他芯片供应商之间的细节稍有 不同），通常被分成更大的组（NVIDIA称之为warps）。虽然每个GPU核心都相对较弱，有时甚至以低于1GHz的 时钟频率运行，但庞大的核心数量使GPU比CPU快几个数量级。之所以有 如此大的差距，原因其实很简单：首先，功耗往往会随时钟频率呈二次方增长。对于一个CPU核心，假设它的 运行速度比GPU快4倍，但可以使用16个GPU核代替，那么GPU的综合性能就是CPU的16 × 1/4 = 4倍。其次， GPU内核要简单得多，这使得它们更节能。此外，深度学习中的许多操作需要相对较高的内存带宽，而GPU拥 有10倍于CPU的带宽。

###  1.2 AlexNet

​		2012年，AlexNet横空出世。它首次证明了学习到的特征可以超越手工设计的特征。它一举打破了计算机视觉研究的现状。AlexNet使用了8层卷积神经网络，并以很大的优势赢得了2012年ImageNet图像识别挑战赛。

![image-20240531102148600](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531102148600.png)

AlexNet和LeNet的设计理念非常相似，但也存在显著差异。 

1. AlexNet比相对较小的LeNet5要深得多。AlexNet由八层组成：五个卷积层、两个全连接隐藏层和一个 全连接输出层。 
2.  AlexNet使用ReLU而不是sigmoid作为其激活函数。 

下面的内容将深入研究AlexNet的细节。



#### 1.2.1 模型设计

​		在AlexNet的第一层，卷积窗口的形状是11×11。由于ImageNet中大多数图像的宽和高比MNIST图像的多10倍 以上，因此，需要一个更大的卷积窗口来捕获目标。第二层中的卷积窗口形状被缩减为5×5，然后是3×3。此 外，在第一层、第二层和第五层卷积层之后，加入窗口形状为3 × 3、步幅为2的最大汇聚层。而且，AlexNet的 卷积通道数目是LeNet的10倍。

​		在最后一个卷积层后有两个全连接层，分别有4096个输出。这两个巨大的全连接层拥有将近1GB的模型参数。 由于早期GPU显存有限，原版的AlexNet采用了双数据流设计，使得每个GPU只负责存储和计算模型的一半 参数。幸运的是，现在GPU显存相对充裕，所以现在很少需要跨GPU分解模型（因此，本书的AlexNet模型在这方面与原始论文稍有不同）。



#### 1.2.2 激活函数

​		此外，AlexNet将sigmoid激活函数改为更简单的ReLU激活函数。一方面，ReLU激活函数的计算更简单，它 不需要如sigmoid激活函数那般复杂的求幂运算。另一方面，当使用不同的参数初始化方法时，ReLU激活函 数使训练模型更加容易。当sigmoid激活函数的输出非常接近于0或1时，这些区域的梯度几乎为0，因此反向 传播无法继续更新一些模型参数。相反，ReLU激活函数在正区间的梯度总是1。因此，如果模型参数没有正 确初始化，sigmoid函数可能在正区间内得到几乎为0的梯度，从而使模型无法得到有效的训练。



#### 1.2.3 容量控制和预处理

​		AlexNet通过暂退法控制全连接层的模型复杂度，而LeNet只使用了权重衰减。为了进一步扩充数 据，AlexNet在训练时增加了大量的图像增强数据，如翻转、裁切和变色。这使得模型更健壮，更大的样本量 有效地减少了过拟合。

```python
# AlexNet

import torch
from torch import nn
from d2l import torch as d2l

# N=（image_h + 2*pad_h – kernel_h）/stride_h+ 1
# 卷积向下取整，池化向上取整。
net = nn.Sequential(
    # 这里使用一个11*11的更大窗口来捕捉对象。
    # 同时，步幅为4，以减少输出的高度和宽度。
    # 另外，输出通道的数目远大于LeNet
    # ([224,224]+2*1-[11,11])/4 +1=[54,54]
    nn.Conv2d(1, 96, kernel_size=11, stride=4, padding=1), nn.ReLU(),
    # ([54,54]-[3,3])/2+1=[26,26]
    nn.MaxPool2d(kernel_size=3, stride=2),
    # 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数
    # ([26,26]+2*2-[5,5]+1)=[26,26]
    nn.Conv2d(96, 256, kernel_size=5, padding=2), nn.ReLU(),
    #([26,26]-[3,3])/2+1=[12,12]
    nn.MaxPool2d(kernel_size=3, stride=2),
    # 使用三个连续的卷积层和较小的卷积窗口。
    # 除了最后的卷积层，输出通道的数量进一步增加。
    # 在前两个卷积层之后，汇聚层不用于减少输入的高度和宽度
    #([12,12]+1*2-[3,3]+1)=[1,384,12,12]
    nn.Conv2d(256, 384, kernel_size=3, padding=1), nn.ReLU(),
    # [1,384,12,12]
    nn.Conv2d(384, 384, kernel_size=3, padding=1), nn.ReLU(),
    #[1,256,12,12]
    nn.Conv2d(384, 256, kernel_size=3, padding=1), nn.ReLU(),
    #([12,12]-[3,3])/2+1=[1,256,5,5]
    nn.MaxPool2d(kernel_size=3, stride=2),
    # 1*256*5*5=6400
    nn.Flatten(),
    # 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合
    nn.Linear(6400, 4096), nn.ReLU(),
    nn.Dropout(p=0.5),
    nn.Linear(4096, 4096), nn.ReLU(),
    nn.Dropout(p=0.5),
    # 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的100
    nn.Linear(4096, 10)
)
X = torch.randn(1, 1, 224, 224)
for layer in net:
    X = layer(X)
    print(layer.__class__.__name__, 'output shape:\t', X.shape)
```

```cmd
Conv2d output shape:	 torch.Size([1, 96, 54, 54])
ReLU output shape:	 torch.Size([1, 96, 54, 54])
MaxPool2d output shape:	 torch.Size([1, 96, 26, 26])
Conv2d output shape:	 torch.Size([1, 256, 26, 26])
ReLU output shape:	 torch.Size([1, 256, 26, 26])
MaxPool2d output shape:	 torch.Size([1, 256, 12, 12])
Conv2d output shape:	 torch.Size([1, 384, 12, 12])
ReLU output shape:	 torch.Size([1, 384, 12, 12])
Conv2d output shape:	 torch.Size([1, 384, 12, 12])
ReLU output shape:	 torch.Size([1, 384, 12, 12])
Conv2d output shape:	 torch.Size([1, 256, 12, 12])
ReLU output shape:	 torch.Size([1, 256, 12, 12])
MaxPool2d output shape:	 torch.Size([1, 256, 5, 5])
Flatten output shape:	 torch.Size([1, 6400])
Linear output shape:	 torch.Size([1, 4096])
ReLU output shape:	 torch.Size([1, 4096])
Dropout output shape:	 torch.Size([1, 4096])
Linear output shape:	 torch.Size([1, 4096])
ReLU output shape:	 torch.Size([1, 4096])
Dropout output shape:	 torch.Size([1, 4096])
Linear output shape:	 torch.Size([1, 10])
```

### 1.3 读取数据集

​		尽管原文中AlexNet是在ImageNet上进行训练的，但本书在这里使用的是Fashion‐MNIST数据集。因为即使在 现代GPU上，训练ImageNet模型，同时使其收敛可能需要数小时或数天的时间。将AlexNet直接应用于Fashion‐ MNIST的一个问题是，Fashion‐MNIST图像的分辨率（28 × 28像素）低于ImageNet图像。为了解决这个问题， 我们将它们增加到224 × 224（通常来讲这不是一个明智的做法，但在这里这样做是为了有效使用AlexNet架 构）。这里需要使用d2l.load_data_fashion_mnist函数中的resize参数执行此调整。

```python
batch_size = 128
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size, resize=224)

```



### 1.4 训练AlexNet

​		现在AlexNet可以开始被训练了。与LeNet相比，这里的主要变化是使用更小的学习速率训练，这是因为网络更深更广、图像分辨率更高，训练卷积神经网络就更昂贵。

```python


def evaluate_accuracy_gpu(net, data_iter, device=None):  #@save
    """使用GPU计算模型在数据集上的精度"""
    if isinstance(net, nn.Module):
        net.eval()  # 设置为评估模式
    if not device:
        device = next(iter(net.parameters())).device
    # 正确预测的数量，总预测的数量
    metric = d2l.Accumulator(2)
    with torch.no_grad():
        for X, y in data_iter:
            if isinstance(X, list):
                # BERT微调所需的（之后将介绍）
                X = [x.to(device) for x in X]
            else:
                X = X.to(device)
            y = y.to(device)
            metric.add(d2l.accuracy(net(X), y), y.numel())
    return metric[0] / metric[1]


def try_gpu(i=0):
    if torch.cuda.device_count() >= i + 1:
        return torch.device(f'cuda:{i}')
    return torch.device('cpu')


def train(net, train_iter, test_iter, num_epochs, lr, device):
    def init_weights(m):
        if type(m) == nn.Linear or type(m) == nn.Conv2d:
            nn.init.xavier_uniform_(m.weight)

    net.apply(init_weights)
    net.to(device)
    optimizer = torch.optim.SGD(net.parameters(), lr=lr)
    loss = nn.CrossEntropyLoss()
    animator = d2l.Animator(xlabel="epoch", xlim=[1, num_epochs],
                            legend=['train loss', 'train acc', 'test acc'])
    timer, num_batches = d2l.Timer(), len(train_iter)
    for epoch in range(num_epochs):
        metric = d2l.Accumulator(3)
        net.train()
        for i, (X, y) in enumerate(train_iter):
            timer.start()
            optimizer.zero_grad()
            X, y = X.to(device), y.to(device)
            y_hat = net(X)
            l = loss(y_hat, y)
            l.backward()
            optimizer.step()
            with torch.no_grad():
                metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0])
            timer.stop()
            train_l = metric[0] / metric[2]
            train_acc = metric[1] / metric[2]
            if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1:
                animator.add(epoch + (i + 1) / num_batches,
                             (train_l, train_acc, None))
        test_acc = evaluate_accuracy_gpu(net, test_iter)
        animator.add(epoch + 1, (None, None, test_acc))
    print(f'loss {train_l:.3f}, train acc {train_acc:.3f}, '
          f'test acc {test_acc:.3f}')
    print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec '
          f'on {str(device)}')


lr, num_epochs = 0.01, 10
train(net, train_iter, test_iter, num_epochs, lr, try_gpu())
```

![image-20240531114136989](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531114136989.png)

## 2. 使用块的神经网络（VGG）

​		虽然AlexNet证明深层神经网络卓有成效，但它没有提供一个通用的模板来指导后续的研究人员设计新的网 络。在下面，我们将介绍一些常用于设计深层神经网络的启发式概念。 与芯片设计中工程师从放置晶体管到逻辑元件再到逻辑块的过程类似，神经网络架构的设计也逐渐变得更加 抽象。研究人员开始从单个神经元的角度思考问题，发展到整个层，现在又转向块，重复层的模式。

### 2.1 VGG块

​	经典卷积神经网络的基本组成部分是下面的这个序列： 

1. 带填充以保持分辨率的卷积层； 
2. 非线性激活函数，如ReLU； 
3. 汇聚层，如最大汇聚层。

​		而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层。在最初的VGG论 文中 (Simonyan and Zisserman, 2014)，作者使用了带有3 × 3卷积核、填充为1（保持高度和宽度）的卷积层， 和带有2 × 2汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层。在下面的代码中，我们定义了一 个名为vgg_block的函数来实现一个VGG块。

​		该函数有三个参数，分别对应于卷积层的数量num_convs、输入通道的数量in_channels 和输出通道的数 量out_channels

```python
# VGG块
import torch
from torch import nn
from d2l import torch as d2l

def vgg_block(num_convs, in_channels, out_channels):
    layers = []
    for _ in range(num_convs):
        layers.append(nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1))
        layers.append(nn.ReLU())
        in_channels = out_channels
    layers.append(nn.MaxPool2d(kernel_size=2, stride=2))
    return nn.Sequential(*layers)
```



### 2.2 VGG网络

​		与AlexNet、LeNet一样，VGG网络可以分为两部分：第一部分主要由卷积层和汇聚层组成，第二部分由全连 接层组成。

![image-20240531115322023](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531115322023.png)

​		VGG神经网络连接 图7.2.1的几个VGG块（在vgg_block函数中定义）。其中有超参数变量conv_arch。该变量 指定了每个VGG块里卷积层个数和输出通道数。全连接模块则与AlexNet中的相同。

​		原始VGG网络有5个卷积块，其中前两个块各有一个卷积层，后三个块各包含两个卷积层。第一个模块有64个 输出通道，每个后续模块将输出通道数量翻倍，直到该数字达到512。由于该网络使用8个卷积层和3个全连接 层，因此它通常被称为VGG‐11。

```python
# VGG-11

def vgg(conv_arch):
    conv_blocks = []
    in_channels = 1
    for (num_convs, out_channels) in conv_arch:
        conv_blocks.append(vgg_block(num_convs,
                                     in_channels=in_channels,
                                     out_channels=out_channels))
        in_channels = out_channels

    return nn.Sequential(*conv_blocks,
                         nn.Flatten(),
                         nn.Linear(out_channels * 7 * 7, 4096), nn.ReLU(), nn.Dropout(0.5),
                         nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(0.5),
                         nn.Linear(4096, 10)
                         )
conv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))
net = vgg(conv_arch=conv_arch)
X = torch.randn(size=(1, 1, 224, 224))
for block in net:
    X = block(X)
    print(block.__class__.__name__, 'output shape:\t', X.shape)
```

```cmd
Sequential output shape:	 torch.Size([1, 64, 112, 112])
Sequential output shape:	 torch.Size([1, 128, 56, 56])
Sequential output shape:	 torch.Size([1, 256, 28, 28])
Sequential output shape:	 torch.Size([1, 512, 14, 14])
Sequential output shape:	 torch.Size([1, 512, 7, 7])
Flatten output shape:	 torch.Size([1, 25088])
Linear output shape:	 torch.Size([1, 4096])
ReLU output shape:	 torch.Size([1, 4096])
Dropout output shape:	 torch.Size([1, 4096])
Linear output shape:	 torch.Size([1, 4096])
ReLU output shape:	 torch.Size([1, 4096])
Dropout output shape:	 torch.Size([1, 4096])
Linear output shape:	 torch.Size([1, 10])
```

我们在每个块的高度和宽度减半，最终高度和宽度都为7。最后再展平表示，送入全连接层处理。

### 2.3 训练模型

​		由于VGG‐11比AlexNet计算量更大，因此我们构建了一个通道数较少的网络，足够用于训练Fashion‐MNIST数 据集。除了使用略高的学习率外，模型训练过程与AlexNet类似。

```python
ratio = 4
small_conv_arch = [(pair[0], pair[1] // ratio) for pair in conv_arch]
net = vgg(conv_arch=small_conv_arch)
lr, num_epochs, batch_size = 0.05, 10, 128
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size, resize=224)
train(net, train_iter, test_iter, num_epochs, lr, try_gpu())
```

![image-20240531145229684](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531145229684.png)

• VGG‐11使用可复用的卷积块构造网络。不同的VGG模型可通过每个块中卷积层数量和输出通道数量的 差异来定义。 

• 块的使用导致网络定义的非常简洁。使用块可以有效地设计复杂的网络。 

• 在VGG论文中，Simonyan和Ziserman尝试了各种架构。特别是他们发现深层且窄的卷积（即3 × 3）比 较浅层且宽的卷积更有效。



## 3. 网络中的网络（NiN）

​		LeNet、AlexNet和VGG都有一个共同的设计模式：通过一系列的卷积层与汇聚层来提取空间结构特征；然后 通过全连接层对特征的表征进行处理。AlexNet和VGG对LeNet的改进主要在于如何扩大和加深这两个模块。 或者，可以想象在这个过程的早期使用全连接层。然而，如果使用了全连接层，可能会完全放弃表征的空间结 构。网络中的网络（NiN）提供了一个非常简单的解决方案：在每个像素的通道上分别使用多层感知机 (Lin et al., 2013)

### 3.1 NiN块

​		回想一下，卷积层的输入和输出由四维张量组成，张量的每个轴分别对应样本、通道、高度和宽度。另外， 全连接层的输入和输出通常是分别对应于样本和特征的二维张量。NiN的想法是在每个像素位置（针对每个 高度和宽度）应用一个全连接层。如果我们将权重连接到每个空间位置，我们可以将其视为1 × 1卷积层，或作为在每个像素位置上独立作用的全连接层。从另一个角度看，即将空间维度中的每个像 素视为单个样本，将通道维度视为不同特征（feature）。

![image-20240531145040820](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531145040820.png)

​		图7.3.1说明了VGG和NiN及它们的块之间主要架构差异。NiN块以一个普通卷积层开始，后面是两个1 × 1的 卷积层。这两个1 × 1卷积层充当带有ReLU激活函数的逐像素全连接层。第一层的卷积窗口形状通常由用户 设置。随后的卷积窗口形状固定为1 × 1。

```python
# NiN 块
import torch
from torch import nn
from d2l import torch as d2l

def nin_block(in_chanels, out_chanels, kernel_size, stride, padding):
    return nn.Sequential(
        nn.Conv2d(in_channels=in_chanels,
                  out_channels=out_chanels,
                  kernel_size=kernel_size,
                  stride=stride,
                  padding=padding),
        nn.ReLU(),
        nn.Conv2d(in_channels=out_chanels,
                  out_channels=out_chanels,
                  kernel_size=kernel_size),
        nn.ReLU(),
        nn.Conv2d(in_channels=out_chanels,
                  out_channels=out_chanels,
                  kernel_size=kernel_size),
        nn.ReLU()
    )
```



### 3.2 NiN模型

​		最初的NiN网络是在AlexNet后不久提出的，显然从中得到了一些启示。NiN使用窗口形状为11×11、5×5和3× 3的卷积层，输出通道数量与AlexNet中的相同。每个NiN块后有一个最大汇聚层，汇聚窗口形状为3 × 3，步 幅为2。

​		NiN和AlexNet之间的一个显著区别是NiN完全取消了全连接层。相反，NiN使用一个NiN块，其输出通道数等 于标签类别的数量。最后放一个全局平均汇聚层（global average pooling layer），生成一个对数几率（logits）。 NiN设计的一个优点是，它显著减少了模型所需参数的数量。然而，在实践中，这种设计有时会增加训练模 型的时间。

```python
net = nn.Sequential(
    nin_block(1, 96, kernel_size=11, stride=4, padding=0),
    nn.MaxPool2d(kernel_size=3, stride=2),
    nin_block(96, 256, kernel_size=5, stride=1, padding=2),
    nn.MaxPool2d(kernel_size=3, stride=2),
    nin_block(256, 384, kernel_size=3, stride=1, padding=1),
    nn.MaxPool2d(kernel_size=3, stride=2),
    nn.Dropout(p=0.5),
    # 标签类别数是10
    nin_block(384, 10, kernel_size=3, stride=1, padding=1),
    nn.AdaptiveAvgPool2d((1, 1)),
    # 将四维的输出转成二维的输出，其形状为(批量大小,10)
    nn.Flatten()
)

X = torch.rand(size=(1, 1, 224, 224))
for layer in net:
    X = layer(X)
    print(layer.__class__.__name__, 'output shape:\t', X.shape)

```

```cmd
Sequential output shape:	 torch.Size([1, 96, 54, 54])
MaxPool2d output shape:	 torch.Size([1, 96, 26, 26])
Sequential output shape:	 torch.Size([1, 256, 26, 26])
MaxPool2d output shape:	 torch.Size([1, 256, 12, 12])
Sequential output shape:	 torch.Size([1, 384, 12, 12])
MaxPool2d output shape:	 torch.Size([1, 384, 5, 5])
Dropout output shape:	 torch.Size([1, 384, 5, 5])
Sequential output shape:	 torch.Size([1, 10, 5, 5])
AdaptiveAvgPool2d output shape:	 torch.Size([1, 10, 1, 1])
Flatten output shape:	 torch.Size([1, 10])
```

### 3.3 训练模型

```python
lr, num_epochs, batch_size = 0.1, 10, 128
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224)
train(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())

```

![image-20240531162257910](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531162257910.png)

• NiN使用由一个卷积层和多个1 × 1卷积层组成的块。该块可以在卷积神经网络中使用，以允许更多的每 像素非线性。 

• NiN去除了容易造成过拟合的全连接层，将它们替换为全局平均汇聚层（即在所有位置上进行求和）。该 汇聚层通道数量为所需的输出数量（例如，Fashion‐MNIST的输出为10）。 

• 移除全连接层可减少过拟合，同时显著减少NiN的参数。 

• NiN的设计影响了许多后续卷积神经网络的设计。





## 4. 含并行连结的网络（GoogLeNet）

​		在2014年的ImageNet图像识别挑战赛中，一个名叫GoogLeNet (Szegedy et al., 2015)的网络架构大放异彩。 GoogLeNet吸收了NiN中串联网络的思想，并在此基础上做了改进。这篇论文的一个重点是解决了什么样 大小的卷积核最合适的问题。毕竟，以前流行的网络使用小到1 × 1，大到11 × 11的卷积核。本文的一个观点 是，有时使用不同大小的卷积核组合是有利的。本节将介绍一个稍微简化的GoogLeNet版本：我们省略了一 些为稳定训练而添加的特殊特性，现在有了更好的训练方法，这些特性不是必要的。

### 4.1 Inception 块

​		在GoogLeNet中，基本的卷积块被称为Inception块（Inception block）。这很可能得名于电影《盗梦空间》（In‐ ception），因为电影中的一句话“我们需要走得更深”（“We need to go deeper”）。

![image-20240531151141620](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531151141620.png)

​		如 图7.4.1所示，Inception块由四条并行路径组成。前三条路径使用窗口大小为1 × 1、3 × 3和5 × 5的卷积层， 从不同空间大小中提取信息。中间的两条路径在输入上执行1 × 1卷积，以减少通道数，从而降低模型的复杂 性。第四条路径使用3 × 3最大汇聚层，然后使用1 × 1卷积层来改变通道数。这四条路径都使用合适的填充 来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。 在Inception块中，通常调整的超参数是每层输出通道数。

```python
# GoogLeNet
import torch
from torch import nn
from torch.nn import functional as F
from d2l import torch as d2l
class Inception(nn.Module):
    # c1--c4是每条路径的输出通道数
    def __init__(self, in_channels, c1, c2, c3, c4, **kwargs):
        super(Inception, self).__init__(**kwargs)
        # 线路1,单1x1卷积层
        self.p1_1 = nn.Conv2d(in_channels=in_channels, out_channels=c1, kernel_size=1)
        # 线路2,1x1卷积层后接3x3卷积层
        self.p2_1 = nn.Conv2d(in_channels=in_channels, out_channels=c2[0], kernel_size=1)
        self.p2_2 = nn.Conv2d(in_channels=c2[0], out_channels=c2[1], kernel_size=3, padding=1)
        # 线路3,1x1卷积层后接5x5卷积层
        self.p3_1 = nn.Conv2d(in_channels=in_channels, out_channels=c3[0], kernel_size=1)
        self.p3_2 = nn.Conv2d(in_channels=c3[0], out_channels=c3[1], kernel_size=5, padding=2)
        # 线路4,3x3最大汇聚层后接1x1卷积层
        self.p4_1 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1)
        self.p4_2 = nn.Conv2d(in_channels=in_channels, out_channels=c4[0], kernel_size=1)

    def forward(self, x):
        p1 = F.relu(self.p1_1(x))
        p2 = F.relu(self.p2_2(F.relu(self.p2_1(x))))
        p3 = F.relu(self.p3_2(F.relu(self.p3_1(x))))
        p4 = F.relu(self.p4_2(F.relu(self.p4_1(x))))
        # 在通道维度上连结输出
        return torch.cat([p1, p2, p3, p4], dim=1)
```

​		那么为什么GoogLeNet这个网络如此有效呢？首先我们考虑一下滤波器（filter）的组合，它们可以用各种滤 波器尺寸探索图像，这意味着不同大小的滤波器可以有效地识别不同范围的图像细节。同时，我们可以为不 同的滤波器分配不同数量的参数。



### 4.2 GoogLeNet模型

![image-20240531153841492](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531153841492.png)

​		GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值。Inception块 之间的最大汇聚层可降低维度。第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平 均汇聚层避免了在最后使用全连接层。

​		现在，我们逐一实现GoogLeNet的每个模块。第一个模块使用64个通道、7 × 7卷积层。

​		第二个模块使用两个卷积层：第一个卷积层是64个通道、1 × 1卷积层；第二个卷积层使用将通道数量增加三 倍的3 × 3卷积层。这对应于Inception块中的第二条路径。

​		第三个模块串联两个完整的Inception块。第一个Inception块的输出通道数为64 + 128 + 32 + 32 = 256，四 个路径之间的输出通道数量比为64 : 128 : 32 : 32 = 2 : 4 : 1 : 1。第二个和第三个路径首先将输入通道的数量 分别减少到96/192 = 1/2和16/192 = 1/12，然后连接第二个卷积层。第二个Inception块的输出通道数增加 到128 + 192 + 96 + 64 = 480，四个路径之间的输出通道数量比为128 : 192 : 96 : 64 = 4 : 6 : 3 : 2。第二条和 第三条路径首先将输入通道的数量分别减少到128/256 = 1/2和32/256 = 1/8。

​		第四模块更加复杂，它串联了5个Inception块，其输出通道数分别是192 + 208 + 48 + 64 = 512、160 + 224 + 64 + 64 = 512、128 + 256 + 64 + 64 = 512、112 + 288 + 64 + 64 = 528和256 + 320 + 128 + 128 = 832。这些 路径的通道数分配和第三模块中的类似，首先是含3×3卷积层的第二条路径输出最多通道，其次是仅含1×1卷 积层的第一条路径，之后是含5×5卷积层的第三条路径和含3×3最大汇聚层的第四条路径。其中第二、第三条 路径都会先按比例减小通道数。这些比例在各个Inception块中都略有不同。

​		第五模块包含输出通道数为256 + 320 + 128 + 128 = 832和384 + 384 + 128 + 128 = 1024的两个Inception块。 其中每条路径通道数的分配思路和第三、第四模块中的一致，只是在具体数值上有所不同。需要注意的是，第 五模块的后面紧跟输出层，该模块同NiN一样使用全局平均汇聚层，将每个通道的高和宽变成1。最后我们将 输出变成二维数组，再接上一个输出个数为标签类别数的全连接层。

```python
# GoogLeNet 

# 假设x=[1,1,96,96]
b1 = nn.Sequential(
    # input: [1,1,96,96]
    # output: [1,64,48,48]
    nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3),
    nn.ReLU(),
    # input: [1,64,48,48]
    # output: [1,64,24,24]
    nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
)

b2 = nn.Sequential(
    # input: [1,64,24,24]
    # output: [1,64,24,24]
    nn.Conv2d(64, 64, kernel_size=1),
    nn.ReLU(),
    # input: [1,64,24,24]
    # output: [1,192,24,24]
    nn.Conv2d(64, 192, kernel_size=3, padding=1),
    nn.ReLU(),
    # input: [1,192,24,24]
    # output: [1,192,12,12]
    nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
)
b3 = nn.Sequential(
    # input: 192
    # output: 64+128+32+32=256
    Inception(192, 64, (96, 128), (16, 32), 32),
    # input: 256 
    # output: 128+192+96+64=480
    Inception(256, 128, (128, 192), (32, 96), 64),
    # input: [1,256,12,12]
    # output: [1,256,6,6]
    nn.MaxPool2d(kernel_size=3, stride=2, padding=1))

b4 = nn.Sequential(
    # input: 480
    # output: 192+208+48+64=512
    Inception(480, 192, (96, 208), (16, 48), 64),
    # input: 512
    # output: 160+224+64+64=512
    Inception(512, 160, (112, 224), (24, 64), 64),
    # output: 128+256+64+64=512
    Inception(512, 128, (128, 256), (24, 64), 64),
    # output: 112+288+64+64=528
    Inception(512, 112, (114, 288), (32, 64), 64),
    # input: 528
    # output: 256+320+128+128=832
    Inception(528, 256, (160, 320), (32, 128), 128),
    # input: [1,832,6,6]
    # output: [1,832,3,3]
    nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
)
b5 = nn.Sequential(
    # input: 832
    # output=256+320+128+128=832
    Inception(832, 256, (160, 320), (32, 128), 128),
    # input: 832
    # output=384+384+128+128=1024
    Inception(832, 384, (192, 384), (48, 128), 128),
    nn.AdaptiveAvgPool2d((1, 1)),
    nn.Flatten()
)

net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(1024, 10))
```

​		GoogLeNet模型的计算复杂，而且不如VGG那样便于修改通道数。为了使Fashion‐MNIST上的训练短小精悍， 我们将输入的高和宽从224降到96，这简化了计算。下面演示各个模块输出的形状变化。

```python
X = torch.rand(size=(1, 1, 96, 96))
for layer in net:
    X = layer(X)
    print(layer.__class__.__name__, 'output shape:\t', X.shape)

```

```cmd
Sequential output shape:	 torch.Size([1, 64, 24, 24])
Sequential output shape:	 torch.Size([1, 192, 12, 12])
Sequential output shape:	 torch.Size([1, 480, 6, 6])
Sequential output shape:	 torch.Size([1, 832, 3, 3])
Sequential output shape:	 torch.Size([1, 1024])
Linear output shape:	 torch.Size([1, 10])
```



### 4.3 训练模型

```python
lr, num_epochs, batch_size = 0.1, 10, 128
train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96)
train(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())
```

![image-20240531163231249](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531163231249.png)

• Inception块相当于一个有4条路径的子网络。它通过不同窗口形状的卷积层和最大汇聚层来并行抽取 信息，并使用1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度。 

• GoogLeNet将多个设计精细的Inception块与其他层（卷积层、全连接层）串联起来。其中Inception块 的通道数分配之比是在ImageNet数据集上通过大量的实验得来的。 

• GoogLeNet和它的后继者们一度是ImageNet上最有效的模型之一：它以较低的计算复杂度提供了类似 的测试精度。



## 5. 批量规范化

​		训练深层神经网络是十分困难的，特别是在较短的时间内使他们收敛更加棘手。本节将介绍批量规范化（batch normalization）(Ioffe and Szegedy, 2015)，这是一种流行且有效的技术，可持续加速深层网络的收敛速度。 再结合在下一节中将介绍的残差块，批量规范化使得能够训练100层以上的网络。

### 5.1 训练深层网络

​		为什么需要批量规范化层呢？让我们来回顾一下训练神经网络时出现的一些实际挑战。

​		首先，数据预处理的方式通常会对最终结果产生巨大影响。在我们应用多层感知机来预测房价的例子中。使用真实数据时，我们的第一步是标准化输入特征，使其平均值为0，方差为1。直观地说，这种标准化可以很好地与我们的优化器配合使用，因为它可以将参数的量级进行统一。

​		第二，对于典型的多层感知机或卷积神经网络。当我们训练时，中间层中的变量（例如，多层感知机中的仿射变换输出）可能具有更广的变化范围：不论是沿着从输入到输出的层，跨同一层中的单元，或是随着时间 的推移，模型参数的随着训练更新变幻莫测。批量规范化的发明者非正式地假设，这些变量分布中的这种偏移可能会阻碍网络的收敛。直观地说，我们可能会猜想，如果一个层的可变值是另一层的100倍，这可能需要对学习率进行补偿调整。

​		第三，更深层的网络很复杂，容易过拟合。这意味着正则化变得更加重要。

​		批量规范化应用于单个可选层（也可以应用到所有层），其原理如下：在每次训练迭代中，我们首先规范化输 入，即通过减去其均值并除以其标准差，其中两者均基于当前小批量处理。接下来，我们应用比例系数和比 例偏移。正是由于这个基于批量统计的标准化，才有了批量规范化的名称。

​		请注意，如果我们尝试使用大小为1的小批量应用批量规范化，我们将无法学到任何东西。这是因为在减去均值之后，每个隐藏单元将为0。所以，只有使用足够大的小批量，批量规范化这种方法才是有效且稳定的。请 注意，在应用批量规范化时，批量大小的选择可能比没有批量规范化时更重要。

​		从形式上来说，用x ∈ B表示一个来自小批量B的输入，批量规范化BN根据以下表达式转换x：

![image-20240531165156043](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531165156043.png)

​		µˆB是小批量B的样本均值，σˆ B是小批量B的样本标准差。应用标准化后，生成的小批量的平均 值为0和单位方差为1。由于单位方差（与其他一些魔法数）是一个主观的选择，因此我们通常包含 拉伸参数 （scale）γ和偏移参数（shift）β，它们的形状与x相同。请注意，γ和β是需要与其他模型参数一起学习的参数。

​		由于在训练过程中，中间层的变化幅度不能过于剧烈，而批量规范化将每一层主动居中，并将它们重新调整 为给定的平均值和大小（通过µˆB和σˆ B）。

​		从形式上来看，我们计算出µˆB和σˆ B，如下所示：

![image-20240531165439385](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531165439385.png)

​		我们在方差估计值中添加一个小的常量ϵ > 0，以确保我们永远不会尝试除以零，即使在经验方差估计值可能消失的情况下也是如此。估计值µˆB和σˆ B通过使用平均值和方差的噪声（noise）估计来抵消缩放问题。乍看起来，这种噪声是一个问题，而事实上它是有益的。

​		事实证明，这是深度学习中一个反复出现的主题。由于尚未在理论上明确的原因，优化中的各种噪声源通 常会导致更快的训练和较少的过拟合：这种变化似乎是正则化的一种形式。在一些初步研究中，(Teye et al., 2018)和 (Luo et al., 2018)分别将批量规范化的性质与贝叶斯先验相关联。这些理论揭示了为什么批量规范化最适应50 ∼ 100范围中的中等批量大小的难题。

​		另外，批量规范化层在”训练模式“（通过小批量统计数据规范化）和“预测模式”（通过数据集统计规范化） 中的功能不同。在训练过程中，我们无法得知使用整个数据集来估计平均值和方差，所以只能根据每个小批 次的平均值和方差不断训练模型。而在预测模式下，可以根据整个数据集精确计算批量规范化所需的平均值 和方差。

### 5.2 批量规范化层

​		批量规范化和其他层之间的一个关键区别是，由于批量规范化在完整的小批量上运行，因此我们 不能像以前在引入其他层时那样忽略批量大小。我们在下面讨论这两种情况：全连接层和卷积层，他们的批量规范化实现略有不同。

#### 5.2.1 全连接层

​		通常，我们将批量规范化层置于全连接层中的仿射变换和激活函数之间。设全连接层的输入为x，权重参数和偏置参数分别为W和b，激活函数为ϕ，批量规范化的运算符为BN。那么，使用批量规范化的全连接层的输 出的计算详情如下：![image-20240531170111359](https://raw.githubusercontent.com/kaisersama112/typora_image/master/image-20240531170111359.png)

#### 5.2.2 卷积层

​		对于卷积层，我们可以在卷积层之后和非线性激活函数之前应用批量规范化。当卷积有多个输出通道时，我们需要对这些通道的“每个”输出执行批量规范化，每个通道都有自己的拉伸（scale）和偏移（shift） 参数，这两个参数都是标量。假设我们的小批量包含m个样本，并且对于每个通道，卷积的输出具有高度p和 宽度q。那么对于卷积层，我们在每个输出通道的m · p · q个元素上同时执行每个批量规范化。因此，在计算 平均值和方差时，我们会收集所有空间位置的值，然后在给定通道内应用相同的均值和方差，以便在每个空间位置对值进行规范化。

#### 4.2.3 预测过程中的批量规范化

​		批量规范化在训练模式和预测模式下的行为通常不同。首先，将训练好的模型用于预测时，我们不再需要样本均值中的噪声以及在微批次上估计每个小批次产生的样本方差了。其次，例如，我们可能需要使用我们的模型对逐个样本进行预测。一种常用的方法是通过移动平均估算整个训练数据集的样本均值和方差，并在预测时使用它们得到确定的输出。可见，和暂退法一样，批量规范化层在训练模式和预测模式下的计算结果也是不一样的。

